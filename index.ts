/**
 * Schemats takes sql database schema and creates corresponding typescript definitions
 * Created by xiamx on 2016-08-10.
 */

import {generateEnumType, generateTableTypes, generateTableInterface, myGenerateTableInterface} from './typescript'
import {getDatabase, Database} from './schema'
import Options, {CAMELCASE_OPTIONS, OptionValues} from './options'
import {processString, Options as ITFOptions} from 'typescript-formatter'
import * as fs from "fs";
const path = require('path');
import {SchemaDefinition, TableDefinition} from "./schemaInterfaces";
import {generateFiles} from "../ts_demo1/src/templateGenerator";
import {camelCase, upperFirst} from "lodash";

const pkgVersion = require('./package.json').version

function getTime() {
    let padTime = (value: number) => `0${value}`.slice(-2)
    let time = new Date()
    const yyyy = time.getFullYear()
    const MM = padTime(time.getMonth() + 1)
    const dd = padTime(time.getDate())
    const hh = padTime(time.getHours())
    const mm = padTime(time.getMinutes())
    const ss = padTime(time.getSeconds())
    return `${yyyy}-${MM}-${dd} ${hh}:${mm}:${ss}`
}

function buildHeader(db: Database, tables: string[], schema: string | null, options: OptionValues): string {
    let commands = ['schemats', 'generate', '-c', db.connectionString.replace(/:\/\/.*@/, '://username:password@')]
    if (options.camelCase) commands.push('-C')
    if (tables.length > 0) {
        tables.forEach((t: string) => {
            commands.push('-t', t)
        })
    }
    if (schema) {
        commands.push('-s', schema)
    }

    //临时去掉
    // `
    //     /**
    //      * AUTO-GENERATED FILE @ ${getTime()} - DO NOT EDIT!
    //      *
    //      * This file was automatically generated by ts_demo v.${pkgVersion}
    //      * $ ${commands.join(' ')}
    //      *
    //      */
    //
    // `
    return`
    /**
     * AUTO-GENERATED FILE @ ${getTime()} - DO NOT EDIT!
     *
     * This file was automatically generated by ts_demo v.${pkgVersion}
     * 
     *
     */\n\n\n`
}

export async function typescriptOfTable(db: Database | string,
                                        directoryPaths: DirectoryPaths,
                                        table: string,
                                        schema: string,
                                        options = new Options(),
                                        schemaDefinition: SchemaDefinition) {
    if (typeof db === 'string') {
        db = getDatabase(db)
    }

    let interfaces = ''
    //let tableTypes = await db.getTableTypes(table, schema, options)
    let tableTypes = await db.myGetTableTypes(table, schema, options)
    interfaces += generateTableTypes(table, tableTypes, options)
   // let interfaceFile = generateTableInterface(table, tableTypes, options);
    //自己的方法
    let myInterfaceFile = myGenerateTableInterface(table, tableTypes, options, schemaDefinition);
    await generateInterfaceFile(directoryPaths.entitiesPath, table, myInterfaceFile);



    await generateDao(table, tableTypes, options, schemaDefinition,directoryPaths);
    interfaces += myInterfaceFile;
    return myInterfaceFile;
}
async function generateDao(table: string, tableTypes: TableDefinition, options: Options, schemaDefinition: SchemaDefinition, directoryPaths: DirectoryPaths) {
    schemaDefinition[table].tableDefinition = tableTypes;
    await generateFiles(schemaDefinition,table,directoryPaths);
}
async function generateInterfaceFile( entitiesPath: string, tableName: string, interfaceString: string) {
    function convertToCamelCase(name: string): string {
        return name.replace(/_([a-z])/g, (match, char) => char.toUpperCase());
    }

    async function formatter(fileName: string, output: string) {
        const formatterOption: ITFOptions = {
            replace: false,
            verify: false,
            tsconfig: true,
            tslint: true,
            editorconfig: true,
            tsfmt: true,
            vscode: false,
            tsconfigFile: null,
            tslintFile: null,
            vscodeFile: null,
            tsfmtFile: null
        }

        const processedResult = await processString(fileName, output, formatterOption)
        return processedResult.dest;
    }


    const fileName = `${upperFirst(camelCase(tableName))}.ts`;
    interfaceString = await formatter(fileName, interfaceString);
    // console.log( `
    //     /**
    //      * AUTO-GENERATED FILE @ ${getTime()} - DO NOT EDIT!
    //      *
    //      * This file was automatically generated by schemats v.${pkgVersion}
    //      * $ ${commands.join(' ')}
    //      *
    //      */
    //
    // `)

    // 检查目录是否存在，如果不存在则创建
    if (fs.existsSync(entitiesPath)) {
        console.log("Directory already exists: \n" + entitiesPath+"\n");
    }

    // 使用修改后的完整输出路径保存文件
    fs.writeFileSync(path.join(entitiesPath,fileName), interfaceString);
    console.log("File saved successfully at: \n" + path.join(entitiesPath, fileName)+"\n");

    //fs.writeFileSync(fileName, interfaceString);
    console.log(`Interface file for table ${tableName} generated and saved to ${fileName}`+"\n");

    //生成DAO Service Controller 代码

    //Dao
}


export async function typescriptOfSchema(db: Database | string,
                                         tables: string[] = [],
                                         orgPath: string,
                                         outputPath:string,
                                         schema: string | null = null,
                                         options: OptionValues = CAMELCASE_OPTIONS
                                         //options: OptionValues = {}
): Promise<string> {
    if (typeof db === 'string') {
        db = getDatabase(db)
    }

    if (!schema) {
        schema = db.getDefaultSchema()
    }

    if (tables.length === 0) {
        tables = await db.getSchemaTables(schema)
    }

    //创建包目录
    let pathList = createDirectories(orgPath,outputPath);


    const optionsObject = new Options(options)

    const enumTypes = generateEnumType(await db.getEnumTypes(schema), optionsObject)
    const schemaDefinition = await db.myGetTableComments(tables, schema)
    const interfacePromises = tables.map((table) => typescriptOfTable(db, pathList, table, schema as string, optionsObject, schemaDefinition))
    const interfaces = await Promise.all(interfacePromises)
        .then(tsOfTable => tsOfTable.join(''))
    let output = '/* tslint:disable */\n\n'
    if (optionsObject.options.writeHeader) {
        output += buildHeader(db, tables, schema, options)
    }
    //output += enumTypes
    output += interfaces

    const formatterOption: ITFOptions = {
        replace: false,
        verify: false,
        tsconfig: true,
        tslint: true,
        editorconfig: true,
        tsfmt: true,
        vscode: false,
        tsconfigFile: null,
        tslintFile: null,
        vscodeFile: null,
        tsfmtFile: null
    }

    const processedResult = await processString("schema.ts", output, formatterOption)
    return processedResult.dest;
   // return output;
}

export interface DirectoryPaths {
    entitiesPath: string;
    daoPath: string;
    daoImplPath: string;
}
const createDirectories = (orgPath:string,outputPath?:string): DirectoryPaths => {
    let rootPath = outputPath || __dirname;
    // 将orgPath转换为正常的包目录结构
    let normalizedOutputPath = orgPath.replace(/\./g, path.sep);
    const srcPath = path.join(rootPath, normalizedOutputPath);

    const entitiesPath = path.join(srcPath, 'entities');
    const daoPath = path.join(srcPath, 'dao');
    const daoImplPath = path.join(daoPath, 'impl');
     logSrc("srcPath",srcPath);
     logSrc("entitiesPath",entitiesPath);
     logSrc("daoPath",daoPath);
     logSrc("daoImplPath",daoImplPath);

    // 创建根目录
    if (!fs.existsSync(srcPath)) {
        fs.mkdirSync(srcPath, { recursive: true });
    }

    // 创建子目录
    [entitiesPath, daoPath, daoImplPath].forEach(function(directory) {
        if (!fs.existsSync(directory)) {
            fs.mkdirSync(directory);
        }
    });


    return { entitiesPath, daoPath, daoImplPath };
};

function logSrc(key:string,value:string) {
    console.log(`===========${key}===========`);
    console.log(value);
    console.log("=============================");
}
export {Database, getDatabase} from './schema'
export {Options, OptionValues}
