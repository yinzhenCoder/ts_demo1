/**
 * Schemats takes sql database schema and creates corresponding typescript definitions
 * Created by xiamx on 2016-08-10.
 */

import { generateEnumType, generateTableTypes, generateTableInterface,myGenerateTableInterface } from './typescript'
import { getDatabase, Database } from './schema'
import Options, {CAMELCASE_OPTIONS, OptionValues} from './options'
import { processString, Options as ITFOptions } from 'typescript-formatter'
import * as fs from "fs";
const pkgVersion = require('./package.json').version

function getTime () {
    let padTime = (value: number) => `0${value}`.slice(-2)
    let time = new Date()
    const yyyy = time.getFullYear()
    const MM = padTime(time.getMonth() + 1)
    const dd = padTime(time.getDate())
    const hh = padTime(time.getHours())
    const mm = padTime(time.getMinutes())
    const ss = padTime(time.getSeconds())
    return `${yyyy}-${MM}-${dd} ${hh}:${mm}:${ss}`
}

function buildHeader (db: Database, tables: string[], schema: string|null, options: OptionValues): string {
    let commands = ['schemats', 'generate', '-c', db.connectionString.replace(/:\/\/.*@/,'://username:password@')]
    if (options.camelCase) commands.push('-C')
    if (tables.length > 0) {
        tables.forEach((t: string) => {
            commands.push('-t', t)
        })
    }
    if (schema) {
        commands.push('-s', schema)
    }

    return `
        /**
         * AUTO-GENERATED FILE @ ${getTime()} - DO NOT EDIT!
         *
         * This file was automatically generated by schemats v.${pkgVersion}
         * $ ${commands.join(' ')}
         *
         */

    `
}

export async function typescriptOfTable (db: Database|string, 
                                         table: string,
                                         schema: string,
                                         options = new Options()) {
    if (typeof db === 'string') {
        db = getDatabase(db)
    }

    let interfaces = ''
    let tableTypes = await db.getTableTypes(table, schema, options)
    interfaces += generateTableTypes(table, tableTypes, options)
    let interfaceFile = generateTableInterface(table, tableTypes, options);
    //自己的方法
    let myInterfaceFile = myGenerateTableInterface(table,tableTypes,options);
    console.log("自己的方法=================================")
    console.log(myInterfaceFile)
    await generateInterfaceFile(table,myInterfaceFile);
    interfaces += interfaceFile;
    return interfaces
}
async function generateInterfaceFile(tableName: string, interfaceString: string) {
    function convertToCamelCase(name: string): string {
        return name.replace(/_([a-z])/g, (match, char) => char.toUpperCase());
    }

    async function formatter(fileName:string,output:string){
        const formatterOption: ITFOptions = {
            replace: false,
            verify: false,
            tsconfig: true,
            tslint: true,
            editorconfig: true,
            tsfmt: true,
            vscode: false,
            tsconfigFile: null,
            tslintFile: null,
            vscodeFile: null,
            tsfmtFile: null
        }

        const processedResult = await processString(fileName, output, formatterOption)
        return processedResult.dest;
    }


    const camelCaseName = convertToCamelCase(tableName);
    const fileName = `${camelCaseName}.ts`;
    console.log(`------------写${fileName}文件--------`)
    console.log("格式化之前")
    console.log(interfaceString)
     interfaceString = await formatter(fileName, interfaceString);
    console.log("格式化之后")
    console.log(interfaceString)
    fs.writeFileSync(fileName, interfaceString);
    console.log(`Interface file for table ${tableName} generated and saved to ${fileName}`);
}



export async function typescriptOfSchema (db: Database|string,
                                          tables: string[] = [],
                                          schema: string|null = null,
                                          options: OptionValues = CAMELCASE_OPTIONS
                                          //options: OptionValues = {}
                                          ): Promise<string> {
    if (typeof db === 'string') {
        db = getDatabase(db)
    }

    if (!schema) {
        schema = db.getDefaultSchema()
    }

    if (tables.length === 0) {
        tables = await db.getSchemaTables(schema)
    }

    const optionsObject = new Options(options)

    const enumTypes = generateEnumType(await db.getEnumTypes(schema), optionsObject)
    const interfacePromises = tables.map((table) => typescriptOfTable(db, table, schema as string, optionsObject))
    const interfaces = await Promise.all(interfacePromises)
        .then(tsOfTable => tsOfTable.join(''))
    console.log("==================================================")
    console.log("------> interfaces")
    console.log(interfaces)
    console.log("<------ interfaces")
    let output = '/* tslint:disable */\n\n'
    if (optionsObject.options.writeHeader) {
        output += buildHeader(db, tables, schema, options)
    }
    console.log("output 添加enumTypes 前\n"+output)
    output += enumTypes
    console.log("output 添加enumTypes 后\n"+output)
    output += interfaces

    const formatterOption: ITFOptions = {
        replace: false,
        verify: false,
        tsconfig: true,
        tslint: true,
        editorconfig: true,
        tsfmt: true,
        vscode: false,
        tsconfigFile: null,
        tslintFile: null,
        vscodeFile: null,
        tsfmtFile: null
    }

    const processedResult = await processString("schema.ts", output, formatterOption)
    console.log("=====================================================")
    //console.log(String(processedResult.dest))
    console.log("Processed Result:");
    console.log("Formatted Code:");
    console.log(processedResult.dest); // 打印格式化后的代码

    console.log("message:");
    console.log(processedResult.message); // 打印处理结果状态

    console.log("Errors:");
    console.log(processedResult.error); // 打印任何处理过程中的错误信息
    console.log("=====================================================")
    return processedResult.dest
}

function convertToCamelCase(name: string): string {
    return name.replace(/_([a-z])/g, (match, char) => char.toUpperCase());
}
export {Database, getDatabase} from './schema'
export {Options, OptionValues}
